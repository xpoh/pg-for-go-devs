# Создание таблицы employees

SQL инструкции для инициализации БД находятся в init/init.sql. Смонтируем эту папку в `/docker-entrypoint-initdb.d` при запуске контейнера:

```bash
docker run \
    -d \
    -p 5432:5432 \
    --name postgres \
    -e POSTGRES_PASSWORD=P@ssw0rd \
    -e PGDATA=/var/lib/postgresql/data \
    -v $HOME/pg-for-go-devs/lesson-2/data:/var/lib/postgresql/data \
    -v $HOME/pg-for-go-devs/lesson-2/init:/docker-entrypoint-initdb.d \
    postgres:13.4
```

Подключимся к созданной БД:

```bash
psql -h 127.0.0.1 -p 5432 -U gopher -d gopher_corp
```

# Insert

Иерархия департаментов имеет древовидную структуру (вопрос: что такое дерево?). В дереве должен быть корневой элемент, создадим его.

```sql
INSERT INTO departments (id, parent_id, name)
VALUES
    (0, 0, 'root');
```

Что пошло не так? Как это исправить?

```sql
INSERT INTO departments (id, parent_id, name)
OVERRIDING SYSTEM VALUE
VALUES
    (0, 0, 'root');
```

Можно ли как-то еще это исправить?

```sql
CREATE TABLE departments (
    id INT GENERATED BY DEFAULT AS IDENTITY,
    parent_id INT NOT NULL,
    name VARCHAR(200)
);
```

В чем разница двух подходов?

# Insert with RETURNING

Давайте представим, что мы описываем структуру организации. Компания разрабатывает два продукта: Romulus и Remus. Пусть R&D разбит на две команды, которые, в свою очередь, разбиты на команды фронтенда, бекэнда и QA. Давайте добавим Romulus в БД:

```sql
INSERT INTO departments (parent_id, name)
VALUES 
    (
        (
            SELECT id
            FROM departments
            WHERE name = 'root'
        ),
        'Romulus'
    );
```

Теперь нам необходимо добавить дочерние для Romulus департаменты:

```sql
INSERT INTO departments (parent_id, name)
VALUES
    (
        (
            SELECT id
            FROM departments
            WHERE name = 'Romulus'
        ),
        'Frontend'
    );
```

А что если бы мы могли вставить строку без дополнительного запроса?

```sql
INSERT INTO departments (parent_id, name)
VALUES 
    (
        (
            SELECT id
            FROM departments
            WHERE name = 'root'
        ),
        'Romulus'
    )
RETURNING id;

INSERT INTO departments (parent_id, name)
VALUES
    (
        5,
        'Frontend'
    );
```

ВНИМАНИЕ! Это синтетический пример, пожалуйста, не делайте так! :)

# Constraints. Check

Давайте запретим выставлять негативную или нулевую зарплату сотрудникам:

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200),
    last_name VARCHAR(200),
    salary MONEY CHECK (salary::numeric > 0),
    manager_id INT,
    department_id INT,
    position INT
);
```

или

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200),
    last_name VARCHAR(200),
    salary MONEY CHECK,
    manager_id INT,
    department_id INT,
    position INT,
    CHECK (salary > 0)
);
```

Проверим:

```sql
INSERT INTO employees (salary)
VALUES 
    (-24);

INSERT INTO employees (salary)
VALUES 
    (0);

INSERT INTO employees (salary)
VALUES 
    (100);
```

# Constraints. Not null

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY CHECK (salary::numeric > 0),
    manager_id INT NOT NULL,
    department_id INT NOT NULL,
    position INT NOT NULL
);
```

Проверим:

```sql
INSERT INTO employees (salary)
VALUES 
    (100);
```

Исправим:

```sql
INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
VALUES 
    ('Alice', 'Liddell', 50000, 4, 8, 15);
```

# Constraints. Foreign key

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL CHECK (salary::numeric > 0),
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
);
```

Что пошло не так? Почему?

# Constraints. Unique

```sql
DROP TABLE IF EXISTS departments CASCADE;

CREATE TABLE departments (
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    parent_id INT NOT NULL,
    name VARCHAR(200) UNIQUE NOT NULL
);

DROP TABLE IF EXISTS positions CASCADE;

CREATE TABLE positions(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    title VARCHAR(200) UNIQUE NOT NULL
);
```

Попробуем еще раз создать employees:

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL CHECK (salary::numeric > 0),
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
);
```

Проверим:

```sql
INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
VALUES 
    ('Alice', 'Liddell', 50000, 4, 8, 15);
```

Исправим. Для этого сначала добавим значения в `departments` и `positions`.

```sql
INSERT INTO departments (id, parent_id, name)
OVERRIDING SYSTEM VALUE
VALUES
    (0, 0, 'root');

INSERT INTO departments (parent_id, name)
VALUES 
    (
        (
            SELECT id
            FROM departments
            WHERE name = 'root'
        ),
        'executives'
    );

INSERT INTO positions (title)
VALUES
    ('CTO');
```

Не ясно как добавить сотрудника:

```sql
INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
VALUES 
    (
        'Alice',
        'Liddell',
        500000,
        ???,
        (SELECT id FROM departments WHERE name = 'executives'),
        (SELECT id FROM positions WHERE title = 'CTO')
    );
```

# Deferrable transactions

Опять поменяем таблицу:

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL CHECK (salary::numeric > 0),
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
        DEFERRABLE INITIALLY DEFERRED
);
```

Попробуем добавить сотрудника:

```sql
BEGIN DEFERRABLE;
    INSERT INTO employees (first_name, last_name, salary, department_id, position)
    VALUES 
        (
            'Alice',
            'Liddell',
            500000,
            (SELECT id FROM departments WHERE name = 'executives'),
            (SELECT id FROM positions WHERE title = 'CTO')
        );
COMMIT;
```

Исправим:

```sql
BEGIN DEFERRABLE;
    INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
    VALUES 
        (
            'Alice',
            'Liddell',
            500000,
            42,
            (SELECT id FROM departments WHERE name = 'executives'),
            (SELECT id FROM positions WHERE title = 'CTO')
        );
    UPDATE employees
    SET manager_id = (
        SELECT id
        FROM employees
        WHERE 
            first_name = 'Alice'
            AND last_name = 'Liddell'
    )
    WHERE
        first_name = 'Alice'
        AND last_name = 'Liddell';
COMMIT;
```

`NOT NULL` в настоящий момент не поддерживает `DEFERRABLE` (это один из очень не многих примеров, когда **Postgres** не соответствует стандарту SQL).

# Constraints. Primary Key

Добавим PK во все таблицы:

```sql
DROP TABLE IF EXISTS departments CASCADE;

CREATE TABLE departments (
    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    parent_id INT NOT NULL,
    name VARCHAR(200) UNIQUE NOT NULL
);

DROP TABLE IF EXISTS positions CASCADE;

CREATE TABLE positions(
    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    title VARCHAR(200) UNIQUE NOT NULL
);

DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL CHECK (salary::numeric > 0),
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
        DEFERRABLE INITIALLY DEFERRED
);
```

Попробуем поменять `UNIQUE` + `NOT NULL` на `PRIMARY KEY`:

```sql
DROP TABLE IF EXISTS departments CASCADE;

CREATE TABLE departments (
    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    parent_id INT NOT NULL,
    name VARCHAR(200) PRIMARY KEY
);
```

Что произошло и почему?

# Явное именование ограничений целостности

Посмотрим на таблицу `employees`:

```sql
\d+ employees
```

Изменим имя ограничения `employees_salary_check`:

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL,
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
        DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT employees_salary_positive_check CHECK (salary::numeric > 0)
);
```

Проверим:

```sql
BEGIN DEFERRABLE;
    INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
    VALUES 
        (
            'Alice',
            'Liddell',
            -500000,
            42,
            (SELECT id FROM departments WHERE name = 'executives'),
            (SELECT id FROM positions WHERE title = 'CTO')
        );
```

# Insert. ON CONFLICT UPDATE

```sql
INSERT INTO departments (id, parent_id, name)
OVERRIDING SYSTEM VALUE
VALUES
    (1, 0, 'execs');
```

Исправим:

```sql
INSERT INTO departments (id, parent_id, name)
OVERRIDING SYSTEM VALUE
VALUES
    (1, 0, 'execs')
ON CONFLICT (id) DO UPDATE
    SET parent_id = excluded.parent_id,
        name = excluded.name;
```

Можно также DO NOTHING:

```sql
INSERT INTO departments (id, parent_id, name)
OVERRIDING SYSTEM VALUE
VALUES
    (1, 0, 'execs')
ON CONFLICT (id) DO NOTHING;
```

# Добавление ограничений к существующим таблицам

Представим, что мы создали `employees` без проверки зарплаты:

```sql
DROP TABLE IF EXISTS employees CASCADE;

CREATE TABLE employees(
    id INT UNIQUE GENERATED ALWAYS AS IDENTITY,
    first_name VARCHAR(200) NOT NULL,
    last_name VARCHAR(200) NOT NULL,
    salary MONEY NOT NULL,
    manager_id INT NOT NULL,
    department_id INT NOT NULL REFERENCES departments(id),
    position INT NOT NULL REFERENCES positions(id),
    FOREIGN KEY (manager_id) REFERENCES employees (id)
        DEFERRABLE INITIALLY DEFERRED
);
```

И начали добавлять сотрудников с отрицательными зарплатами:

```sql
INSERT INTO positions (title)
VALUES
    ('CEO'),
    ('CSO');

BEGIN DEFERRABLE;
    INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
    VALUES 
        (
            'Bob',
            'Morane',
            -500000,
            42,
            (SELECT id FROM departments WHERE name = 'execs'),
            (SELECT id FROM positions WHERE title = 'CSO')
        );
    UPDATE employees
    SET manager_id = (
        SELECT id
        FROM employees
        WHERE 
            first_name = 'Bob'
            AND last_name = 'Morane'
    )
    WHERE
        first_name = 'Bob'
        AND last_name = 'Morane';

    INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
    VALUES 
        (
            'Charley',
            'Bucket',
            -1000000,
            42,
            (SELECT id FROM departments WHERE name = 'execs'),
            (SELECT id FROM positions WHERE title = 'CEO')
        );
    UPDATE employees
    SET manager_id = (
        SELECT id
        FROM employees
        WHERE 
            first_name = 'Charley'
            AND last_name = 'Bucket'
    )
    WHERE
        first_name = 'Charley'
        AND last_name = 'Bucket';
COMMIT;
```

Теперь попробуем добавить ограничение:

```sql
ALTER TABLE employees
ADD CONSTRAINT employees_salary_positive_check CHECK (salary::numeric > 0);
```

Что наблюдаем?

Поправим:

```sql
ALTER TABLE employees
ADD CONSTRAINT employees_salary_positive_check CHECK (salary::numeric > 0) NOT VALID;
```

Проверим:

```sql
BEGIN DEFERRABLE;
    INSERT INTO employees (first_name, last_name, salary, manager_id, department_id, position)
    VALUES 
        (
            'Alice',
            'Liddell',
            -500000,
            42,
            (SELECT id FROM departments WHERE name = 'execs'),
            (SELECT id FROM positions WHERE title = 'CTO')
        );
    UPDATE employees
    SET manager_id = (
        SELECT id
        FROM employees
        WHERE 
            first_name = 'Alice'
            AND last_name = 'Liddell'
    )
    WHERE
        first_name = 'Alice'
        AND last_name = 'Liddell';
COMMIT;
```

Почистим данные и проверим ограничение:

```sql
ALTER TABLE employees
VALIDATE constraint employees_salary_positive_check;

UPDATE employees
SET salary = (-(salary::numeric))::MONEY
WHERE salary::numeric < 0;

ALTER TABLE employees
VALIDATE constraint employees_salary_positive_check;
```

# CTE

Перепишем запросы на добавление департаментов, используя CTE:

```sql
DROP TABLE IF EXISTS departments CASCADE;

CREATE TABLE departments (
    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    parent_id INT NOT NULL,
    name VARCHAR(200) UNIQUE NOT NULL
);

WITH 
    dept_root AS (
        INSERT INTO departments (id, parent_id, name)
        OVERRIDING SYSTEM VALUE
        VALUES
            (0, 0, 'root')
        RETURNING id
    ),
    dept_rnd AS (
        INSERT INTO departments (parent_id, name)
        VALUES
            (
                (SELECT id FROM dept_root),
                'R&D'
            )
        RETURNING id
    )
INSERT INTO departments (parent_id, name)
VALUES 
    (
        (SELECT id FROM dept_root),
        'executives'
    ),
    (
        (SELECT id FROM dept_rnd),
        'Romulus'
    ),
    (
        (SELECT id FROM dept_rnd),
        'Remus'
    );
```

# CTE. WITH RECURSIVE

Найдем "путь" от департамента `Romulus` к корневому департмаенту.

```sql
WITH RECURSIVE dept_chain(id, parent_id) AS (
    SELECT id, parent_id
    FROM departments
    WHERE name = 'Romulus'

    UNION

    SELECT d.id, d.parent_id
    FROM departments d
    JOIN dept_chain dc
        ON d.id = dc.parent_id
)
SELECT *
FROM dept_chain;
```

Что произойдет, если изменить запрос:

```sql
WITH RECURSIVE dept_chain(id, parent_id) AS (
    SELECT id, parent_id
    FROM departments
    WHERE name = 'Romulus'

    UNION ALL

    SELECT d.id, d.parent_id
    FROM departments d
    JOIN dept_chain dc
        ON d.id = dc.parent_id
)
SELECT *
FROM dept_chain;
```

Как это "исправить"?

```sql
WITH RECURSIVE dept_chain(id, parent_id) AS (
    SELECT id, parent_id
    FROM departments
    WHERE name = 'Romulus'

    UNION ALL

    SELECT d.id, d.parent_id
    FROM departments d
    JOIN dept_chain dc
        ON d.id = dc.parent_id
    WHERE d.id != d.parent_id
)
SELECT *
FROM dept_chain;
```

# Импорт данных. mock-data

```bash
mkdir -p mock && sudo chown -R 10000 mock

docker run \
    --rm \
    --name mock-pg \
    -v $HOME/pg-for-go-devs/lesson-2/mock:/home/mock \
    ghcr.io/pivotal-gss/mock-data:latest \
    -a 172.17.0.2 \
    -d gopher_corp \
    -u gopher \
    -w P@ssw0rd \
    -r 100 \
    tables -t departments,positions,employees
```

# Оценка занимаемого места. Табличные данные

```sql
SELECT oid::regclass::text AS tablename, pg_total_relation_size(oid) AS size_bytes
FROM pg_class
WHERE relkind = 'r'
ORDER BY size_bytes DESC;
```

Почему значения отличаются от полученных при помощи `\d+`?

```sql
SELECT oid::regclass::text AS tablename, pg_table_size(oid) AS table_size, pg_indexes_size(oid) AS indexes_size, pg_total_relation_size(oid) AS total_size
FROM pg_class
WHERE relkind = 'r' AND oid::regclass::text = 'employees'
;
```

# Оценка занимаемого места. Подсчет количества строк

```sql
SELECT count(*)
FROM departments;
```

Оптимизируем (потеряв в точности):

```sql
SELECT oid::regclass::text AS tablename, reltuples::bigint AS rows_estim
FROM pg_class
WHERE oid::regclass::text = 'departments';
```

Посмотрим конкретную таблицу:

```sql
SELECT oid::regclass::text AS tablename, reltuples::bigint AS rows_estim
FROM pg_class
WHERE oid::regclass::text = 'employees';
```